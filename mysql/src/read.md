#### Mysql架构与历史
- MySql逻辑架构
    - 连接管理与安全性<br>
        每一个客户端连接都会在服务器上进程中有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或销毁线程。
    - 优化与执行<br>
        MySql会解析查询，并创建内部数据结构（解析树），然后对其各种优化，包括重写查询、决定表的读写顺序、以及选择合适的索引等。
    - 并发控制<br>
        读锁（共享锁）、写锁（排他锁）；表锁、行级锁
    - 事物：A(原子性)C(一致性)I(隔离性)D(持久性)<br>  
        - 隔离级别<br/>
            - 未提交读（read uncommitted）：事物中的修改，即使没有提交，对其他事物也是可见的。
            - 提交读（read committed）：一个事物开始，只能看见提交了的事物做的修改。
            - 可重复读（pereatable read）:保证了同一个事物中多次读取同样记录的结果一直。并采用MVCC解决幻读的问题。MYSQL默认的事物隔离级别。
            - 可串行化（serializable）：强制事物串行执行 
        - 死锁<br/>
            - InnoDB 目前处理死锁的方法是：将持有最少行级别排它锁（写锁）的事物进行回滚。
        - 事物日志<br/>
            - 事物日志可以提高事物的处理能力。先将修改表的数据拷贝到内存，再把行为记录在日志中。后期再将数据写入到磁盘中。 
    - 多版本并发控制(MVCC)<br/>
        InnoDB的MVCC，是通过在每行记录后面保存2个隐藏的列来实现的。
    - InnoDB概览
        - InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。
        - InnoDB采用MVCC来支持高并发，并采用了可重复读的隔离级别，通过间隙锁策略防止幻读的出现。
               
    

![image](https://github.com/ButBueatiful/dotvim/raw/master/screenshots/v)




#### MySql基准测试
- 为什么需要基准测试<br/>
    因为基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。
- 基准测试的策略<br/>
    - 集成式以及单组件式基准测试
    - 测试指标<br/>
        - 吞吐量：单位时间内处理事务的数量
        - 响应时间：用于测试任务的所需整体时间
        - 并发性（Http是无状态的）
        - 可扩展性
- 基准的测试方法<br/>
- 基准测试工具<br/>

    
   
 
#### 服务器性能剖析
- 性能：完成某件任务所需要的时间，完成一项任务可以分为执行时间和等待时间
    - 执行时间：通过定位每一个子任务花费的时间
    - 等待时间：这个比较复杂，可能是其他系统间的影响导致，也可能是争用磁盘和CPU资源引起的
- 性能剖析步骤：
    - 测量任务所需要的时间
    - 对结果进行排序和统计
- 剖析Mysql查询
    - 慢查询日志 ---> 使用pt-query-digest工具
    - 抓取TCP网络包
- 剖析单条查询
    - 使用 show ProFile：使用show Profiles;show Profile for query Query_Id
    - 使用 show status
    - 使用慢查询日志
- 使用性能剖析
- 诊断间歇性问题
    - 使用 show global status:
    - 使用 show processlist
    - 使用查询日志：
    - 理解发现的问题：使用gnuplot和R绘图工具
- 捕获诊断数据
    - gdb命令使用
- 间断性问题解决思路
    - 首先，问题是什么？一定要把问题清楚描述出来
    - 其次，为解决这个问题做过了什么操作？
- 什么可能导致性能低下
    - 资源被过度使用，余量不足以正常工作
    - 资源没有正确的配置
    - 资源已经损坏或者失灵


#### Schema(模式)与数据类型优化
- 选择优化的数据类型
    - 变小的通常更好
    - 简单就好
    - 避免null
    - TIMESTAMP只会使用DATETIME的一半的内存空间，并且会根据时区变化，具有特殊的自动更新能力。不过其允许的时间范围小的多
- 整数类型
    - TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 分别使用8，16，24，32、64位
    - UNSIGNED 不允许有负值
    - 对于存储和计算来说，INT(1)和INT(20)是一样的
- 实数类型
    - FLOAT使用4个字节、Double使用8个字节
    - DECIMAL需要占用额外的空间和计算开销，所以只用在对小数进行精确计算时使用--财务数据。当数据量比较大，也可以使用BIGINT代替，乘以相应倍数即可
- 字符串类型
    - VARCHAR类型可以存储会变长度的字符串。但在Update的时候，如果行内没有了足够的空间增长，并且页内没有更多的存储空间，INNODB就需要分裂页来使行可以放进页内。
    - CHAR是固定的长度。
    - BLOB、TEXT都是存储大的字符串设计的
    - 使用枚举替代字符串
    - 时间类型
        - DATETIME：能保存最大值，从1001年到9999年，精度为s,与时区无关，使用8个字节存储
        - TIMESTAMP：保存了1970年1月1日（格林尼治标准时间），使用4个字节存储，
    - 位数据类型
    - 特殊类型：使用INET_AUTO()和INET_NTOA()存储ip    
- 范式和反范式
    - 范式: 在范式化的数据库中，每个事实数据会出现并且只有一次。
    - 反范式: 信息是冗余的，可能存储在多个地方
- 混合范式和反范式化
- 缓存表和汇总表
    
    
    
#### 创建高性能的索引
- 索引的类型
    - B-Tree索引：通常意味着所有值都是按顺序存储排列的，并且每个叶子到根节点的距离相同。
        - 适用于全值匹配、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配某一列并范围匹配另外一列
    - Hash索引：




#### 查询性能的优化

#### 