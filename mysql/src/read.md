#### Mysql架构与历史
- MySql逻辑架构
    - 连接管理与安全性<br>
        每一个客户端连接都会在服务器上进程中有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或销毁线程。
    - 优化与执行<br>
        MySql会解析查询，并创建内部数据结构（解析树），然后对其各种优化，包括重写查询、决定表的读写顺序、以及选择合适的索引等。
    - 并发控制<br>
        读锁（共享锁）、写锁（排他锁）；表锁、行级锁
    - 事物：A(原子性)C(一致性)I(隔离性)D(持久性)<br>  
        - 隔离级别<br/>
            - 未提交读（read uncommitted）：事物中的修改，即使没有提交，对其他事物也是可见的。
            - 提交读（read committed）：一个事物开始，只能看见提交了的事物做的修改。
            - 可重复读（pereatable read）:保证了同一个事物中多次读取同样记录的结果一直。并采用MVCC解决幻读的问题。MYSQL默认的事物隔离级别。
            - 可串行化（serializable）：强制事物串行执行 
        - 死锁<br/>
            - InnoDB 目前处理死锁的方法是：将持有最少行级别排它锁（写锁）的事物进行回滚。
        - 事物日志<br/>
            - 事物日志可以提高事物的处理能力。先将修改表的数据拷贝到内存，再把行为记录在日志中。后期再将数据写入到磁盘中。 
    - 多版本并发控制(MVCC)<br/>
        InnoDB的MVCC，是通过在每行记录后面保存2个隐藏的列来实现的。
    - InnoDB概览
        - InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。
        - InnoDB采用MVCC来支持高并发，并采用了可重复读的隔离级别，通过间隙锁策略防止幻读的出现。
               
    

![image](https://github.com/ButBueatiful/dotvim/raw/master/screenshots/v)




#### MySql基准测试
- 为什么需要基准测试<br/>
    因为基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。
- 基准测试的策略<br/>
    - 集成式以及单组件式基准测试
    - 测试指标<br/>
        - 吞吐量：单位时间内处理事务的数量
        - 响应时间：用于测试任务的所需整体时间
        - 并发性（Http是无状态的）
        - 可扩展性
- 基准的测试方法<br/>
- 基准测试工具<br/>

    
   
 
#### 服务器性能剖析
- 性能：完成某件任务所需要的时间，完成一项任务可以分为执行时间和等待时间
    - 执行时间：通过定位每一个子任务花费的时间
    - 等待时间：这个比较复杂，可能是其他系统间的影响导致，也可能是争用磁盘和CPU资源引起的
- 性能剖析步骤：
    - 测量任务所需要的时间
    - 对结果进行排序和统计
- 剖析Mysql查询
    - 慢查询日志 ---> 使用pt-query-digest工具
    - 抓取TCP网络包
- 剖析单条查询
    - 使用 show ProFile：使用show Profiles;show Profile for query Query_Id
    - 使用 show status
    - 使用慢查询日志
- 使用性能剖析
- 诊断间歇性问题
    - 使用 show global status:
    - 使用 show processlist
    - 使用查询日志：
    - 理解发现的问题：使用gnuplot和R绘图工具
- 捕获诊断数据
    - gdb命令使用
- 间断性问题解决思路
    - 首先，问题是什么？一定要把问题清楚描述出来
    - 其次，为解决这个问题做过了什么操作？
- 什么可能导致性能低下
    - 资源被过度使用，余量不足以正常工作
    - 资源没有正确的配置
    - 资源已经损坏或者失灵


#### Schema(模式)与数据类型优化
- 选择优化的数据类型
    - 变小的通常更好
    - 简单就好
    - 避免null
    - TIMESTAMP只会使用DATETIME的一半的内存空间，并且会根据时区变化，具有特殊的自动更新能力。不过其允许的时间范围小的多
- 整数类型
    - TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 分别使用8，16，24，32、64位
    - UNSIGNED 不允许有负值
    - 对于存储和计算来说，INT(1)和INT(20)是一样的
- 实数类型
    - FLOAT使用4个字节、Double使用8个字节
    - DECIMAL需要占用额外的空间和计算开销，所以只用在对小数进行精确计算时使用--财务数据。当数据量比较大，也可以使用BIGINT代替，乘以相应倍数即可
- 字符串类型
    - VARCHAR类型可以存储会变长度的字符串。但在Update的时候，如果行内没有了足够的空间增长，并且页内没有更多的存储空间，INNODB就需要分裂页来使行可以放进页内。
    - CHAR是固定的长度。
    - BLOB、TEXT都是存储大的字符串设计的
    - 使用枚举替代字符串
    - 时间类型
        - DATETIME：能保存最大值，从1001年到9999年，精度为s,与时区无关，使用8个字节存储
        - TIMESTAMP：保存了1970年1月1日（格林尼治标准时间），使用4个字节存储，
    - 位数据类型
    - 特殊类型：使用INET_AUTO()和INET_NTOA()存储ip    
- 范式和反范式
    - 范式: 在范式化的数据库中，每个事实数据会出现并且只有一次。
    - 反范式: 信息是冗余的，可能存储在多个地方
- 混合范式和反范式化
- 缓存表和汇总表
    
    
    
#### 创建高性能的索引
- 索引的类型
    - B-Tree索引：通常意味着所有值都是按顺序存储排列的，并且每个叶子到根节点的距离相同。
        - 适用于全值匹配、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配某一列并范围匹配另外一列
    - Hash索引：基于hash表实现，只有精确匹配索引所有列的查询才有效。
        - 局限：无法排序、范围查询、
- 索引的优点
    - 索引大大减少了服务器需要扫描的数据量
    - 索引可以帮助服务器避免排序和零时表
    - 索引可以将随机io变为有序io
- 索引策略
    - 独立的列：指索引列不能作为表达式一部分及函数的参数
    - 前缀索引
    - 多列索引
    - 聚簇索引：不是一种单独的索引，而是一种存储方式
        - 顺序的主键在高并发时候可能会有更坏的结果，需要重新设计表结构或更改采用innodb_autoinc_lock_mode配置
    - 覆盖索引
        - 一个索引包含了（或覆盖了）所有需要查询的字段
    - 使用索引扫描来做排序
    - 未使用的索引
        - 最简单有效的办法是在Percona Server或者MariaDB中打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，
        再通过查询Information_schema.index_statistics就能查询到每个索引的使用频率了
    - 索引和锁
        - 索引可以让查询锁定更少的行。InnoDB只有在访问行时才会对其加锁，而索引能减少对InnoDB访问，从而减少锁的数量
--- 案例
        
       


#### 查询性能的优化
- 慢查询基础：优化数据访问
    - 分析：确认应用程序是否检索大量超过需要的数据；确认MySQL服务器是否存在分析大量超过需要的数据行
    - 是否向数据库请求了不需要的数据
        -案例：查询不需要的记录；多表关联时返回全部列；总是取出全部列；重复查询相同的数据
    - MySql是否在扫描额外的记录
        - 指标：响应时间；扫描的行数；返回的行数
        - 响应时间：服务时间，排队时间
        - 一般mysql能够使用三种where条件，从好到坏依次执行：
            - 在索引中使用where条件来过滤不匹配的记录。这是存储引擎层完成的
            - 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是Mysql服务器完成的，但无需再回表查询记录
            - 从数据表中返回数据，然后过滤不满足条件的记录（在Extra中出现Using Where）,这是Mysql
    - 如果发现查询需要扫描大量的数据但只返回少量的行，可以采用以下技巧取优化：
        - 使用索引覆盖扫描，把所有需要用到的列都放在索引中，这样存储引擎无需回表获取对应行就可以返回结果了
        - 改变库表结构。例如使用单独的汇总表
        - 重写这个复杂的查询，让MySql优化器能够以更优化的方式执行这个查询
    - 查询执行的基础
        - 查询状态
            show full processlist
        - 查询缓存
        - 查询优化处理
            - 语法解析器和预处理
                通过关键字对sql语句解析，并生成一棵对应的“解析树”，解析器根据语法规则进行验证和解析查询
            - 查询优化器（找到最好的执行计划）
    - Mysql查询优化器的限定（6.5）
              
                
            
            


#### 



#### 补充
- for update是在数据库中上锁用的，可以为数据库中的行上一个排它（写）锁
- 执行顺序
1)from 
(3) join 
(2) on 
(4) where 
(5)group by(开始使用select中的别名，后面的语句中都可以使用)
(6) avg,sum.... 
(7)having 
(8) select 
(9) distinct 
(10) order by
(11) limit 
