## redis设计与实现
### 数据结构与对象
#### 简单的动态字符串
- SDS的定义
    - free 属性，表示这个sds没有分配任何未使用空间
    - len 属性，表示这个sds保存的字符串长度
    - buf 属性，是一个char类型的数组，最后一个字节保存了空字符串'\0' 
- SDS 与 C字符串的区别
    1. 常数复杂度获取字符串长度（c字符串并不记录自身长度信息，每次需要遍历）
    2. 杜绝缓冲区溢出（字符串拼接时需要先申请足够空间）
    3. 减少修改字符串时带来的内存重新分配次数
        - 空间预分配(公式)
            - 当修改后SDS的len小于1MB,则len和free属性的值相等；
            - 大于1MB,则free=1MB
        - 惰性空间释放
    4. 二进制安全（兼容图片、音频等二进制数据）
    5. 兼容部分C字符串函数
        
#### 链表
- 链表和链表节点的实现
    1. listNode包含头尾指针和值
    2. list包含多个listNode，主要结构有头尾节点指针，长度，复制函数，释放函数，节点值对比函数
- 应用：列表键，发布与订阅，慢查询，监控器等     

#### 字典
- 字典（每个字典有2个hash表）的实现
    1. 哈希表
        - 组成：hash表数组，哈希表大小，哈希表大小掩码（总等于size-1），已有节点数量
        - 每个数组都指向一个dictEntry,有size属性和used属性则记录哈希表目前已有节点数量
    2. 哈希表节点
        - 组成：key,value(指针或int64或uint64),指向下一个节点的next
    3. 字典
    4. 哈希算法
    5. 解决键冲突
        - 因为dictEntry没有指向链表的尾指针，所以新节点是加在链表头位置
    6. rehash步骤
        1. 为ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（即ht[0].used属性值）
            - 如果是扩展操作，则为第一个大于等于ht[0].used * 2的2的n次方
            - 如果是收缩操作，则为第一个大于等于ht[0].used 的2的n次方
        2. 将保存在ht[0]中的数据都rehash到ht[1]上：rehash是指重新计算键的哈希值及索引值，然后将键值对放到ht[1]的指定位置
        3. 当ht[0]的数据全部迁移后，释放ht[0],将ht[1]设置为ht[0],并重新创建ht[1]的空白哈希表，为下一次rehash做准备
     7. 渐进式的rehash步骤
        
#### 跳跃表
- 跳跃表的实现
    - 组成：由zskiplistNode和zskiplist2个结构定义
        - zskiplist结构
            - header:指向跳跃表的表头结点
            - tail:指向跳跃表的表尾节点
            - level:记录跳跃表内，层数最大的那个节点层数
            - length:记录跳跃表的长度
        - zskiplistNode结构
            - 层（level）:一般来说，层数越多，访问别的节点越快
            - 后退BW(backward)：
            - 分值（score）
            - 成员对象（obj）

#### 整数集合

#### 压缩列表

#### 对象

### 单机数据库的实现

### 多机数据库的实现

### 独立功能的实现
