### 自动内存管理机制
- java内存区域与内存溢出异常
- 运行时数据区域
- 程序计数器
    - 是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器
    - 分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器
    - 唯一一个与OutOfMemoryError相关的区域
- java虚拟机栈
    - 每个方法执行时都会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等。
    - 2中异常：StackOverflowError和OutOfMemoryError
- 本地方法栈
- Java堆
    - jvm管理中内存区域最大的一块，唯一的目的就是用来存放对象实例
    - 通过-Xmx和-Xms控制堆大小，没有内存空间，则会抛出OutOfMemoryError
- 方法区
    - 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 运行时常量池
    - 属于方法区的一部分
- 直接内存
    - 并不是jvm运行时数据区的一部分，也不是虚拟机中定义的内存区域
    - 在jdk1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象对这块内存的引用进行操作。
- HotSpot虚拟机对象探秘
- 对象的创建
- 对象的内存布局
    - 对象头：包含2部分信息。第一部分用于存储对象自身的运行时数据，如哈希码、GCf分代年龄、锁状态标志等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，倘若是数组，则还需存放数组长度的数据
    - 实例数据：使用句柄访问，那么Java堆中就需要划分一块内存用来作为句柄池，reference中存储的就是对象的句柄地址；如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象地址
    - 对齐填充
- 垃圾收集器与内存分配策略
- 对象已死吗？
- 引用计数算法
    - 问题：互相循环计数问题
- 可达性分析算法
    - 从GC Roots 看对象是否可达
    - java可以作为GC Roots的对象包括一下几种
        - 虚拟机栈（栈帧中的本地变量表）中引用的对象
        - 方法区中的静态属性引用的对象
        - 方法区中常量引用
        - 本地方法栈中JNI引用的对象
- 再谈引用
    - 强引用
    - 软引用：在内存发生溢出之前，会将这些对象列进行垃圾回收，这次回收内存还是不够，则发生内存溢出。在jdk1.2之后，提供了SoftReference类来实现
    - 弱引用：只能生存到下一次垃圾收集发生之前。在jdk1.2之后，提供了WeakReference类来实现
    - 虚引用：一个对象是否有虚引用的存在，完全不会影响它的生成时间，也无法通过虚引用来创建一个对象，唯一的目的就是能在这个对象被收集器回收时收到一个系统通知。在jdk1.2之后，提供了PhantomReference类来实现
- 生存还是死亡(运行代价昂贵，不确定性大，无法保证各个对象的调用顺序)
    - 要宣告一个对象是否真正死亡，至少要经历过2次标记过程。如果对象在进行可达性分析后发现没有与GC相连接的引用链，那它会被标记一次并进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()或者finalize()已经执行过一次，虚拟机都将这两种情况视为没有必要执行。
- 回收方法区
- 垃圾收集算法
    - 标记-清除算法
        - 不足之处：效率问题，标记和清楚2个过程的效率都不高；空间问题，标记清楚后会造成大量不连续的内存碎片
    - 复制算法（新生代使用）
        - 新生代每次收集都发现有大量对象死去，只有少数存活
    - 标记整理算法（老年代使用）
        - 老年代对象存活率高，没有额外空间做担保
-

