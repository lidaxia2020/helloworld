### 自动内存管理机制
- java内存区域与内存溢出异常
- 运行时数据区域
- 程序计数器
    - 是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器
    - 分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器
    - 唯一一个与OutOfMemoryError相关的区域
- java虚拟机栈
    - 每个方法执行时都会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等。
    - 2中异常：StackOverflowError和OutOfMemoryError
- 本地方法栈
- Java堆
    - jvm管理中内存区域最大的一块，唯一的目的就是用来存放对象实例
    - 通过-Xmx和-Xms控制堆大小，没有内存空间，则会抛出OutOfMemoryError
- 方法区
    - 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 运行时常量池
    - 属于方法区的一部分
- 直接内存
    - 并不是jvm运行时数据区的一部分，也不是虚拟机中定义的内存区域
    - 在jdk1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象对这块内存的引用进行操作。
- HotSpot虚拟机对象探秘
- 对象的创建
- 对象的内存布局
    - 对象头：包含2部分信息。第一部分用于存储对象自身的运行时数据，如哈希码、GCf分代年龄、锁状态标志等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，倘若是数组，则还需存放数组长度的数据
    - 实例数据：使用句柄访问，那么Java堆中就需要划分一块内存用来作为句柄池，reference中存储的就是对象的句柄地址；如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象地址
    - 对齐填充
- 垃圾收集器与内存分配策略
- 对象已死吗？
- 引用计数算法
    - 问题：互相循环计数问题
- 可达性分析算法
    - 从GC Roots 看对象是否可达
    - java可以作为GC Roots的对象包括一下几种
        - 虚拟机栈（栈帧中的本地变量表）中引用的对象
        - 方法区中的静态属性引用的对象
        - 方法区中常量引用
        - 本地方法栈中JNI引用的对象
- 再谈引用
    - 强引用
    - 软引用：在内存发生溢出之前，会将这些对象列进行垃圾回收，这次回收内存还是不够，则发生内存溢出。在jdk1.2之后，提供了SoftReference类来实现
    - 弱引用：只能生存到下一次垃圾收集发生之前。在jdk1.2之后，提供了WeakReference类来实现
    - 虚引用：一个对象是否有虚引用的存在，完全不会影响它的生成时间，也无法通过虚引用来创建一个对象，唯一的目的就是能在这个对象被收集器回收时收到一个系统通知。在jdk1.2之后，提供了PhantomReference类来实现
- 生存还是死亡(运行代价昂贵，不确定性大，无法保证各个对象的调用顺序)
    - 要宣告一个对象是否真正死亡，至少要经历过2次标记过程。如果对象在进行可达性分析后发现没有与GC相连接的引用链，那它会被标记一次并进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()或者finalize()已经执行过一次，虚拟机都将这两种情况视为没有必要执行。
- 回收方法区
- 垃圾收集算法
    - 标记-清除算法
        - 不足之处：效率问题，标记和清楚2个过程的效率都不高；空间问题，标记清楚后会造成大量不连续的内存碎片
    - 复制算法（新生代使用）
        - 新生代每次收集都发现有大量对象死去，只有少数存活
    - 标记整理算法（老年代使用）
        - 老年代对象存活率高，没有额外空间做担保
- 垃圾收集器
    - Serial收集器（复制算法）
        - 这是一个“单线程”的收集器，并且他进行收集垃圾的时候，必须暂停其他所有的工作线程，直到它收集结束。--“stop the world”
        - 适用于client模式下的虚拟机
    - ParNew收集器（复制算法）
        - 是Serial收集器升级版本，并且目前只有他能和CMS收集器配合使用
    - Parallel Scavenge收集器
        - 关注点是达到一个可控制的额吞吐量（吞吐量=运行用户的代码时间/（运行用户的代码时间+垃圾收集时间））
    - Serial Old收集器（标记-整理算法）
    - Parallel Old收集器（标记-整理算法）
    - CMS收集器（Concurrent Mark Sweep）
        - 初始标记
            - “stop the world”;只是标记了一下GC Roots能直接关联到的对象
        - 并发标记
        - 重新标记
            - “stop the world”;
        - 并发清除
    - G1收集器
        - 并行和并发
        - 分代收集
        - 空间整合
        - 可预测停顿
- 理解GC日志
- 垃圾收集器参数总结
- 内存分配与回收策略
    - 对象优先分配在Eden区
    - 大对象直接进入老年代
    - 长期存活的对象将进入老年代
    - 动态对象年龄判断
    - 空间分配担保
### 虚拟机性能监控与故障处理
- JDK的命令行工具
    - jps 显示指定系统内所有的HotSpot虚拟机进程（jps -l）
        - 命令格式：jps [option] [hostid(远程注册及名)]
    - jstat 用于收集HotSpot虚拟机各方面运行时数据
        - jstat [option vmid [interval[s|ms][count]]
    - jinof 显示虚拟机配置信息
    - jmap 生成虚拟机内存转储快照（heapdump文件）
        - 格式：jmap [option] vmid
    - jhat 用于分析heapdump文件，它会建立一个Http/Html服务器，让用户可以在浏览器查看
    - jstack 显示虚拟机的线程快照
- JDK可视化工具
    - JConsole:Java监视与管理控制台
    - VisualVM
        - Profiler插件
        - BTrace动态日志跟踪插件


### 虚拟机执行子系统（回头细看）
- 类文件结构
    - class文件格式采用了类似c语言的伪结构来存储数据，只有2种类型：无符号数和表
    - 每个class文件的头4个字节称为魔数，他唯一的作用是确定这个文件能不能被虚拟机接受，值为0xCAFEBABE
    -

### 虚拟机类加载机制
- 过程：加载-->验证-->准备-->解析-->初始化-->使用-->卸载
- 加载
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转换为方法区运行时数据结构
    - 在内存种生成一个代表这个类的Java.class.Class对象，作为方法区这个类的各种数据访问入口
- 验证
    - 目的：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求
- 准备
- 解析
- 初始化
    - 真正开始执行类中定义的java代码（字节码）
- 类加载器
    - 双亲委派模型
        - 3种类加载器：启动类加载器、扩展类加载器、应用程序类加载器
        - 工作原理：如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这个类，而是交给它的父类加载器去完成，每一个层次的类都是采用了这种模式，只有当父类反应没有能力完成时，才会让子类去加载
        - 破坏双亲委派模型
            - jdk1.2之前
            - JNDI服务（命名规范），采用线程上下文切换
            - 程序员对代码动态的追求，热部署等

### 虚拟机字节码执行引擎
- 运行时栈帧结构
    - 组成：局部变量表、操作数栈、动态连接、返回地址
    - 局部变量表
    - 操作数栈
- 分派
    -

























