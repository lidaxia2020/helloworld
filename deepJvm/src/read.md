### 自动内存管理机制
    - java内存区域与内存溢出异常
        - 运行时数据区域
            - 程序计数器
                - 是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器
                - 分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器
                - 唯一一个与OutOfMemoryError相关的区域
            - java虚拟机栈
                - 每个方法执行时都会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等。
                - 2中异常：StackOverflowError和OutOfMemoryError
            - 本地方法栈
            - Java堆
                - jvm管理中内存区域最大的一块，唯一的目的就是用来存放对象实例
                - 通过-Xmx和-Xms控制堆大小，没有内存空间，则会抛出OutOfMemoryError
            - 方法区
                - 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
            - 运行时常量池
                - 属于方法区的一部分
            - 直接内存
                - 并不是jvm运行时数据区的一部分，也不是虚拟机中定义的内存区域
                - 在jdk1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象对这块内存的引用进行操作。
        - HotSpot虚拟机对象探秘
            - 对象的创建
            - 对象的内存布局
                - 对象头：包含2部分信息。第一部分用于存储对象自身的运行时数据，如哈希码、GCf分代年龄、锁状态标志等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，倘若是数组，则还需存放数组长度的数据
                - 实例数据：使用句柄访问，那么Java堆中就需要划分一块内存用来作为句柄池，reference中存储的就是对象的句柄地址；如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象地址
                - 对齐填充：


